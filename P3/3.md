# 类和对象的提高

## this指针
作用就是指向成员函数所作用的对象
```cpp
class Complex{
    public:
    double real,img;
    void Pint(){}
    Complex(double r,double i):real(r),img(i){}
    void Print(){
        cout<<"real="<<real<<",img="<<img<<endl;
    }
    Complex AddOne(){
        this->real++;
        this->img++;
        return *this;//this指针返回的是作用的对象
    }
}

int main(){
    Complex c1(1,2),c2(3,4);
    c2 = c1.AddOne()//作用在c1上
    return 0;
}
```

this指针实际上就是cpp在翻译成c语言的时候，用this指针待指struct对象

**注意静态成员函数不能使用this指针**

## 静态成员
static关键字
静态成员函数只能访问静态成员变量

静态成员变量在类中声明，在类外定义


## 静态成员变量
只有一份被所有对象共享。sizeof运算符不会计算静态成员变量的大小。本质上静态成员是放在全局数据区

## 静态成员函数
静态成员函数只能访问静态成员变量，不具体作用于某个对象。本质是一种全局函数。

**设置静态成员这种机制的目的是将某些类紧密相连的全局变量和函数写到一个整体内，看起来像一个整体，易于维护和理解。**

**注意**：
1. 需要在定义类的文件中对静态成员变量进行一次说明或者初始化。否则编译能通过，链接不能通过。
2. 静态成员函数，不能访问非静态成员变量，也不能调用非静态成员函数。

# 成员对象和封闭类

封闭类（enclosing）：
一个类的成员变量如果是另一个类的对象，就称之为“成员对象”。包含成员对象的类叫封闭类。

在构造函数中添加初始化列表的写法如下：
```cpp
// 类名::构造函数名(参数表): 成员变量1(参数表), 成员变量2(参数表), ...
// {
//     ...
// }
class CTyre //轮胎类
{
    private:
        int radius; //半径
        int width; //宽度
    public:
        CTyre(int r, int w) : radius(r), width(w) { }//直接就是将r赋值给radius
};
class CEngine //引擎类
{
};
class CCar { //汽车类
    private:
        int price; //价格
        CTyre tyre;
        CEngine engine;
    public:
        CCar(int p, int tr, int tw);
};


```

封闭类构造函数和析折函数的执行顺序

1. 封闭类对象生成时候，先执行所有对象成员的构造函数，然后执行封闭类的构造函数。
2. 对象成员构造函数的调用次序和对象成员在类中的说明次序相同和，在初始化列表中出现的次序不同。
3. 封闭类对象消亡是，先执行封闭类的析构函数，然后执行成员对象的析构函数。次序和构造函数的调用次序相反。

## 常量
const关键字；
常量成员函数不能改变非常量对象参数，
void func() const;
常量成员函数的重载；如果函数定义一个有const一个没有const那就就会发生重载而不是复杂构造函数
常引用
void func(const class & c);

## 友元(friends)
友元函数：
1. 友元函数可以访问类的所有成员
2. 友元函数可以被任意对象调用
3. 友元函数的调用方式和普通函数相同

class Ccar;
class CDriver
{

};

友元类：
1. 友元类可以访问所有成员
2. 友元类可以被任意对象调用
3. 友元类和普通类一样，可以有构造函数和析构函数

友元类之间的关系不能传递不能继承